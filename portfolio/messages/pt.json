{
  "Bio": {
    "alt": "Foto de Guilherme Beckman",
    "role": "Desenvolvedor FullStack",
    "name": "Guilherme Beckman",
    "status": "Atualmente estagiando no IFMS"
  },
  "Education": {
    "educationTitle": "EDUCAÇÃO",
    "primary": "Ensino Fundamental I",
    "primaryCourse": "Primário",
    "fundamentalSchool2": "Ensino Fundamental II",
    "fundamentalSchool2Course": "Secundário",
    "highSchool": "Ensino Médio",
    "technicalIT": "Técnico em Informática para Internet",
    "technologist": "Tecnólogo",
    "systemsAnalysis": "Análise e Desenvolvimento de Sistemas",
    "certification": "Certificação",
    "awsRestart": "Programa AWS re/Start",
    "sesiCorumba": "SESI Corumbá, MS",
    "senaiCorumba": "SENAI Corumbá, MS",
    "faculdadeLocal": "IFMS Corumbá, MS",
    "aws": "AWS re/Start"
  },
  "Experience": {
    "acaox": "ACAOX Contabilidade",
    "backendEngineer": "Desenvolvedor FullStack",
    "acaoxDescription": "Liderei o desenvolvimento de dois sistemas: ACTUS, uma plataforma full-stack de validação contábil construída com Java 21, Spring Boot 4 e Angular 20, com motor de regras CSV com mais de 284 regras de validação, processamento multi-formato de documentos (PDF, Excel, CSV), dashboards analíticos em tempo real e controle de acesso baseado em JWT; e um gerador de regras com IA usando arquitetura RAG com Google Gemini 2.0 Flash e ChromaDB, automatizando a criação de regras contábeis estruturadas a partir dos pronunciamentos CPC brasileiros. Gerenciei 36 migrações de banco via Flyway no PostgreSQL em mais de 296 commits e realizei deploy em produção usando contêineres Docker.",
    "ifms": "IFMS - LIADS",
    "onsite": "Presencial",
    "fullstackInfra": "FullStack / Infra",
    "ifmsDescription": "Trabalhei no LIADS na parte de infraestrutura, tendo a função de configurar um servidor do zero (on-premise), no qual a arquitetura foi planejada para suportar Microserviços. Para isso, implementei um API Gateway utilizando o software Kong, que utilizava um DNS resolver com Consul para mapear os IPs dos microsserviços, facilitando o registro e a comunicação entre eles. Além disso, utilizei Ubuntu Server, Docker e Docker Compose para conteinerização. Também realizo manutenção em projetos já existentes, incluindo um chatbot para a Prefeitura de Corumbá-MS e um software para leitura e digitalização de peças da cultura pantaneira.",
    "ifmsFacial": "IFMS - Projeto de Pesquisa",
    "research": "Pesquisa Científica",
    "researcher": "Pesquisador / Bolsista",
    "ifmsFacialDescription": "Desenvolvimento de um sistema de reconhecimento facial para controle de acesso, utilizando Python, OpenCV e a biblioteca face_recognition. O projeto envolveu captura de imagem via webcam, comparação com banco de dados local e registro de tentativas de acesso em PostgreSQL. Foram realizados testes em diferentes condições de iluminação e ângulos, além da produção de relatório técnico com resultados e recomendações."
  },
  "SkillsTable": {
    "stackTitle": "Stack Técnica",
    "stackSubtitle": "Tecnologias e ferramentas que utilizo para construir soluções inovadoras",
    "categories": {
      "frontend": "Desenvolvimento Frontend",
      "backend": "Backend & APIs",
      "cloud": "Cloud & DevOps",
      "tools": "Ferramentas de Desenvolvimento"
    }
  },
  "SkillsData": {
    "angular": {
      "description": "Framework para construir SPAs modernas com TypeScript."
    },
    "kong": {
      "description": "API Gateway para roteamento e segurança."
    },
    "awsEc2": {
      "description": "Serviço de instâncias virtuais na nuvem."
    },
    "laravel": {
      "description": "Framework PHP para desenvolvimento rápido de APIs."
    },
    "awsRoute53": {
      "description": "Serviço de DNS escalável da AWS."
    },
    "mongodb": {
      "description": "Banco de dados NoSQL orientado a documentos."
    },
    "awsS3": {
      "description": "Armazenamento de arquivos escalável na nuvem."
    },
    "mysql": {
      "description": "Banco de dados relacional amplamente usado."
    },
    "aws": {
      "description": "Serviços de nuvem da Amazon para infraestrutura e aplicações."
    },
    "nextjs": {
      "description": "Framework React para aplicações SSR e estáticas."
    },
    "consul": {
      "description": "Ferramenta para descoberta e configuração de serviços."
    },
    "nginx": {
      "description": "Servidor web e proxy reverso de alto desempenho."
    },
    "css3": {
      "description": "Folhas de estilo para estilizar páginas web."
    },
    "onshape": {
      "description": "Plataforma de CAD 3D na nuvem."
    },
    "docker": {
      "description": "Containerização de aplicações para consistência e portabilidade."
    },
    "php": {
      "description": "Linguagem de programação para web backend."
    },
    "fastapi": {
      "description": "Framework Python para APIs rápidas e modernas."
    },
    "postgresql": {
      "description": "Banco de dados relacional avançado e open-source."
    },
    "github": {
      "description": "Plataforma de versionamento e colaboração de código."
    },
    "gitMerge": {
      "description": "Operação de versionamento para integrar branches."
    },
    "git": {
      "description": "Sistema de controle de versão distribuído."
    },
    "html5": {
      "description": "Linguagem de marcação para estruturar páginas web."
    },
    "react": {
      "description": "Biblioteca JavaScript para construir UIs interativas."
    },
    "reactAlt": {
      "description": "Alternativa de logo React para portfólio."
    },
    "ionic": {
      "description": "Framework para apps mobile híbridos."
    },
    "java": {
      "description": "Linguagem de programação orientada a objetos."
    },
    "spring": {
      "description": "Framework Java para construção de aplicações robustas."
    },
    "javascript": {
      "description": "Linguagem de programação para comportamento web."
    },
    "typescript": {
      "description": "Superset do JavaScript com tipagem estática."
    },
    "python": {
      "description": "Linguagem de programação versátil e popular."
    },
    "rabbitmq": {
      "description": "Sistema de mensageria para aplicações distribuídas."
    },
    "postman": {
      "description": "Ferramenta para testar e documentar APIs."
    },
    "arduino": {
      "description": "Plataforma de prototipagem eletrônica para IoT e automação."
    },
    "linux": {
      "description": "Sistema operacional open-source usado em servidores e desenvolvimento."
    },
    "microservices": {
      "description": "Arquitetura para desenvolvimento de aplicações distribuídas e escaláveis."
    },
    "opencv": {
      "description": "Biblioteca de visão computacional para processamento de imagens."
    },
    "faceid": {
      "description": "Tecnologia de reconhecimento facial para autenticação e segurança."
    },
    "shell": {
      "description": "Scripts de linha de comando para automação de tarefas."
    }
  },
  "Contact": {
    "title": "Contatos",
    "external": "Externo",
    "location": "Localização"
  },
  "Resume": {
    "title": "ME CONTRATA",
    "subtitle": "Desenvolvedor full-stack focado em backend e infra. Vamos trabalhar juntos?",
    "contact": "Fale comigo",
    "download": "Baixar CV (PDF)",
    "aria": "Visualizador de currículo em PDF",
    "fallback": "Não foi possível embutir o PDF no seu navegador.",
    "open": "Abrir o currículo em uma nova aba",
    "or": "ou",
    "downloadFile": "baixar o arquivo"
  },
  "Nav": {
    "home": "Início",
    "about": "Sobre",
    "projects": "Projetos",
    "resume": "Currículo"
  },
  "Projects": {
    "title": "Projetos",
    "subtitle": "Uma coleção de projetos que demonstram minhas habilidades em desenvolvimento web, design e resolução de problemas.",
    "MySell": {
      "title": "MySell",
      "description": "Aplicação que ajuda pequenos empreendedores a registrar suas vendas diárias. Possui autenticação JWT, login com Google e Facebook, cadastro de produtos e vendas, relatórios em PDF e histórico de vendas."
    },
    "BirdPantanal": {
      "title": "Bird Pantanal Photo Gallery",
      "description": "Explore uma galeria digital dedicada às aves do Pantanal, com artigos e descrições detalhadas de cada espécie."
    },
    "OrderManager": {
      "title": "Sistema de Gerenciamento de Pedidos Online",
      "description": "Um sistema baseado em microsserviços para restaurantes, onde clientes podem fazer pedidos, restaurantes gerenciam cardápios e status dos pedidos, com autenticação, filas RabbitMQ e serviços em contêineres Docker."
    },
    "LiadsServer": {
      "title": "Servidor LIADS IFMS On-premise",
      "description": "Servidor desenvolvido para centralizar e gerenciar o registro de diversos projetos do Liads IFMS, simplificando o processo de deploy. Ele adota uma arquitetura baseada em microsserviços e utiliza conteinerização para garantir escalabilidade e facilidade de manutenção."
    },
    "IoTSchoolBell": {
      "title": "Sistema de Sinal Escolar Automatizado",
      "description": "Projeto de IoT para automatizar o sinal escolar na SESI Corumbá-MS. Arduino com ESP8266 controla o sinal, enquanto backend em Python FastAPI com SQLite gerencia os horários via WebSocket/HTTP. Frontend em Next.js permite configurar os horários facilmente."
    },
    "FaceRecognition": {
      "title": "Sistema de Reconhecimento Facial",
      "description": "Sistema de reconhecimento facial desenvolvido em Python utilizando a biblioteca face_recognition. Captura imagens de câmera, processa e armazena os rostos no banco de dados PostgreSQL. Arquitetura baseada em microserviços com módulos em Python (reconhecimento), Java (segurança) e Golang (auditoria). Projeto em andamento, atualmente na fase de planejamento, com prazo de um ano para desenvolvimento."
    },
    "EcoCarona": {
      "title": "Eco-Carona",
      "description": "Uma plataforma full-stack de caronas sustentáveis construída com Go e Next.js. Possui gerenciamento de usuários e veículos com operações CRUD, validação de formulários e stack Dockerizada com PostgreSQL + Go + Next.js."
    },
    "Actus": {
      "title": "ACTUS",
      "description": "Plataforma integrada de validação contábil construída do zero com Java 21, Spring Boot 4 e Angular 20. Possui motor de regras CSV com mais de 284 regras de validação, processamento multi-formato de documentos, dashboards analíticos em tempo real e geração automatizada de relatórios PDF para auditoria e compliance."
    },
    "AiRuleGenerator": {
      "title": "Gerador de Regras Contábeis com IA",
      "description": "Sistema com IA usando arquitetura RAG com Google Gemini 2.0 Flash e ChromaDB para gerar automaticamente regras de validação contábil estruturadas a partir dos pronunciamentos CPC brasileiros. Produz 200–300 regras validadas por execução a custo quase zero."
    }
  },
  "NavProject": {
    "backToProjects": "Voltar para projetos",
    "github": "GitHub",
    "liveDemo": "Demo"
  },
  "ProjectCard": {
    "moreInfo": "Mais informações",
    "code": "Código"
  },
  "ProjectPage": {
    "MySell": {
      "title": "MySell",
      "subtitle": "Dashboard inteligente de vendas para pequenos empreendedores",
      "description": "Aplicação que ajuda pequenos empreendedores a registrar suas vendas diárias. Possui autenticação JWT, login com Google e Facebook, cadastro de produtos e vendas, relatórios em PDF, histórico de vendas e proteção contra acessos suspeitos.",
      "features": "Cadastro de Usuário; Login de Usuário; Autenticação com Google;Autenticação com Facebook; Verificação de E-mail; Bloqueio após Tentativas Falhas; E-mail de Boas-Vindas; Cadastro de Produtos (QR Code); CRUD de Produtos; Registro e Exclusão de Vendas; Histórico de Vendas; Relatórios em PDF; Cache para Performance; Proteção de Rotas",
      "demo": {
        "dashboard": "Dashboard",
        "bancoDeDados": "Banco de dados",
        "loginRaw": "Login",
        "registerRaw": "Registro",
        "googleLogin": "Login - Google",
        "facebookLogin": "Login - Facebook",
        "criandoProdutos": "Criando Produtos",
        "produtosPreCriados": "Produtos Existentes",
        "editandoProdutos": "Editando Produtos",
        "excluindoProdutos": "Excluindo Produtos",
        "vendendoProdutos": "Vendendo Produtos",
        "excluindoVendas": "Excluindo Vendas",
        "qrCodeProdutos": "Produtos com QR Code",
        "gerandoRelatoriosPDF": "Relatórios em PDF",
        "graficoRelatorios": "Gráfico de Relatórios",
        "excecaoBruteForce": "Exceção Brute Force",
        "visaoGeralAplicacao": "Geral",
        "buscandoCoisas": "Buscando"
      },
      "statistics": {
        "activeUsers": "Usuários Ativos",
        "uptime": "Tempo de Atividade",
        "performanceScore": "Pontuação de Performance"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "initialPlanning": "Planejamento Inicial",
        "betaRelease": "Backend",
        "firstVersion": "Finaliza Api",
        "officialLaunch": "Frontend",
        "finalVersion": "Finaliza o Frontend"
      }
    },
    "BirdPantanal": {
      "title": "Bird Pantanal Photo Gallery",
      "subtitle": "Galeria digital de aves do Pantanal",
      "description": "Bird Pantanal Photo Gallery é uma galeria digital dedicada às aves do Pantanal, apresentando artigos detalhados sobre cada espécie. A aplicação permite explorar diferentes aves com descrições informativas, proporcionando um espaço para apreciar a fauna local.",
      "features": "Listar todas as aves; Buscar dados de uma ave específica; Criar novas aves; Atualizar dados de aves; Excluir aves; Criar usuários; Login com geração de token JWT; Proteção de rotas com JWT",
      "demo": {
        "creating": "Criando",
        "downloadCard": "Baixando Cartão",
        "login": "Login",
        "delete": "Deletando",
        "editing": "Editando",
        "searching": "Buscando",
        "fluxogram": "Fluxograma"
      },
      "statistics": {
        "birds": "Pássaros Registrados",
        "uptime": "Tempo de Atividade"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "initialPlanning": "Planejamento inicial e definição do escopo",
        "betaRelease": "Beta Release",
        "apiReady": "API pronta e testada",
        "firstVersion": "Primeira Versão",
        "frontendCompleted": "Frontend concluído",
        "officialLaunch": "Lançamento Oficial",
        "firstDeploy": "Primeiro deploy oficial",
        "finalVersion": "Versão Final",
        "awsInfrastructure": "Infraestrutura final na AWS"
      }
    },
    "OrderManager": {
      "title": "Sistema de Gerenciamento de Pedidos Online",
      "subtitle": "Sistema de pedidos para restaurantes baseado em microsserviços",
      "description": "Este projeto é um sistema completo de gerenciamento de pedidos para restaurantes utilizando arquitetura de microsserviços. Inclui autenticação com JWT, papéis de usuário, filas de pedidos com RabbitMQ, MongoDB para armazenamento e Docker para deploy em contêineres.",
      "features": "Autenticação com JWT; Controle de acesso baseado em papéis; Cadastro e login de usuários; Perfil do cliente e histórico de pedidos; Gerenciamento de cardápio e produtos; Processamento de pedidos com filas; Atualização de status em tempo real; Documentação da API com Postman",
      "demo": {
        "systemDesign": "Diagrama do Sistema",
        "postman1": "Requisições Postman",
        "microservices": "Microservices"
      },
      "statistics": {
        "microservices": "Microsserviços",
        "users": "Usuários Simulados"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "initialPlanning": "Planejamento inicial e levantamento de requisitos",
        "firstServices": "Primeiros Microsserviços",
        "basicArchitecture": "Implementação da arquitetura básica com autenticação",
        "integration": "Fase de Integração",
        "rabbitMqWorking": "Filas do RabbitMQ conectadas entre serviços",
        "testing": "Testes e Documentação",
        "postmanDocs": "Coleção do Postman concluída",
        "deploy": "Deploy",
        "containerizedDeploy": "Deploy utilizando contêineres Docker"
      }
    },
    "Liads": {
      "title": "Servidor On-premise LIADS IFMS",
      "subtitle": "Infraestrutura de microsserviços com Docker, Kong, Consul e Nginx",
      "description": "O LIADS Server é uma infraestrutura on-premise projetada para gerenciar múltiplos serviços com isolamento, roteamento e verificação de saúde. Ele utiliza Docker para conteinerização, Kong como API Gateway, Consul como registro e resolvedor DNS de serviços e Nginx como proxy reverso. O projeto tem como objetivo simplificar o registro e o roteamento de serviços dentro da rede local do IFMS.",
      "features": "Conteinerização de serviços com Docker; Roteamento automático via Kong; Resolução DNS com Consul; Health checks de todos os serviços; Registro de serviços facilitado; Arquitetura modular de microsserviços; Deploy on-premise em Ubuntu Server",
      "statistics": {
        "registeredServices": "Serviços Registrados",
        "uptime": "Disponibilidade",
        "infrastructure": "Infraestrutura"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "initialPlanning": "Planejamento inicial e definição da stack",
        "baseInfrastructure": "Configuração da Infraestrutura Base",
        "kongConsulSetup": "Kong + Consul configurados e rodando",
        "currentDevelopment": "Desenvolvimento Atual",
        "serviceRegistration": "Primeiros serviços registrados no Consul e roteados via Kong"
      },
      "demo": {
        "infrastructureDiagram": "Diagrama da Infraestrutura",
        "consulDashboard": "Consul",
        "kongRoutes": "Rotas no Kong",
        "dockerCompose": "Docker Compose",
        "ubuntuOnPremise": "Ubuntu On-Premise"
      }
    },
    "IoTSchoolBell": {
      "title": "Sistema de Sinal Escolar Automatizado",
      "subtitle": "Projeto IoT desenvolvido para a Escola SESI de Corumbá-MS",
      "description": "Desenvolvido em parceria com um colega, este projeto de IoT tem como objetivo automatizar o sinal escolar, eliminando a necessidade de acionamento manual pela coordenação. Utilizamos Arduino com ESP8266 para controlar o dispositivo físico e uma API em Python com FastAPI, integrada ao SQLAlchemy e Alembic para persistência de dados em SQLite. A comunicação com o Arduino é feita via WebSocket e HTTP, recebendo os horários configurados em um scheduler e acionando o sinal de forma automática. O frontend em Next.js com TypeScript permite que os administradores configurem os horários de forma simples e intuitiva.",
      "features": "Integração com Arduino e ESP8266; API em Python com FastAPI; ORM com SQLAlchemy; Migrações com Alembic; Banco de dados SQLite; Comunicação via WebSocket; Comunicação via HTTP; Scheduler de horários; Frontend em Next.js; Código aberto no GitHub",
      "statistics": {
        "devicesConnected": "Dispositivos Conectados",
        "scheduledRings": "Toques Programados",
        "manualIntervention": "Intervenções Manuais Necessárias"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "initialPlanning": "Planejamento inicial e definição de arquitetura",
        "hardwareIntegration": "Integração do Hardware",
        "arduinoTests": "Testes com Arduino + ESP8266",
        "apiDevelopment": "Desenvolvimento da API",
        "fastApiIntegration": "Integração da API em FastAPI com banco de dados",
        "frontendDevelopment": "Desenvolvimento do Frontend",
        "schedulerUI": "Criação da interface de configuração de horários",
        "productionDeployment": "Implantação em Produção",
        "systemOperational": "Sistema operacional e em uso"
      },
      "demo": {
        "thinkercad": "Thinkercad",
        "figma": "Figma Frontend",
        "onshape": "Onshape CAD",
        "cCode": "Código em C"
      }
    },
    "FaceRecognition": {
      "title": "Sistema de Reconhecimento Facial",
      "subtitle": "Identificação automática de rostos com arquitetura de microserviços",
      "description": "Projeto focado no desenvolvimento de um sistema de reconhecimento facial utilizando Python e a biblioteca face_recognition. As imagens são processadas, comparadas e armazenadas em um banco PostgreSQL. A arquitetura é baseada em microserviços, com módulos para segurança e auditoria em Java e Golang, garantindo robustez e escalabilidade. Estou liderando uma pequena equipe com duas pessoas menos experientes, orientando-as durante todo o processo de desenvolvimento.",
      "features": "Reconhecimento facial; Captura de imagens; Armazenamento de faces; Módulo de segurança; Módulo de auditoria; Arquitetura de microserviço; Desenvolvimento iterativo",
      "statistics": {
        "projectStatus": "Status do Projeto",
        "planningPhase": "Em fase de planejamento",
        "estimatedDuration": "Duração Estimada",
        "teamMembers": "Membros da Equipe"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "initialPlanning": "Planejamento inicial e definição de escopo",
        "softwareDevelopment": "Desenvolvimento do Software",
        "pythonImplementation": "Implementação do reconhecimento facial em Python",
        "securityModule": "Módulo de Segurança",
        "javaIntegration": "Integração do módulo de segurança em Java",
        "auditModule": "Módulo de Auditoria",
        "golangImplementation": "Implementação do módulo de auditoria em Golang",
        "testingDeployment": "Testes e Deploy",
        "systemRelease": "Primeira versão liberada para uso"
      },
      "demo": {
        "systemArchitecture": "Arquitetura do Sistema"
      }
    },
    "EcoCarona": {
      "title": "Eco-Carona",
      "subtitle": "Plataforma de Caronas Sustentáveis",
      "description": "Eco-Carona é uma aplicação full-stack projetada para promover caronas sustentáveis conectando motoristas e passageiros. Construída com backend em Go usando Gin e GORM, e frontend em Next.js 15 com TypeScript, TailwindCSS e componentes Shadcn UI. A aplicação possui gerenciamento completo de usuários e veículos com arquitetura limpa em camadas.",
      "features": "Gerenciamento de usuários com validação de CPF; Cadastro de veículos com especificações detalhadas; Tabelas de dados interativas com edição/exclusão; Validação de formulários com Zod e React Hook Form; API RESTful com Go e Gin; Gerenciamento de turnos/horários; Deploy full-stack com Docker; Design responsivo com TailwindCSS",
      "demo": {
        "usersTable": "Tabela de Usuários",
        "createUserForm": "Formulário de Criação de Usuário",
        "usersTableData": "Gerenciamento de Usuários",
        "carsTableData": "Gerenciamento de Carros",
        "backendControllers": "Controladores do Backend",
        "backendArchitecture": "Arquitetura do Backend"
      },
      "statistics": {
        "commits": "Total de Commits",
        "apiEndpoints": "Endpoints da API",
        "developmentTime": "Tempo de Desenvolvimento",
        "status": "Status"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "backendSetup": "Configuração do backend com Go, Gin, GORM e PostgreSQL",
        "backendDev": "Desenvolvimento do Backend",
        "apiImplementation": "Implementação da API REST para usuários e carros",
        "frontendDev": "Desenvolvimento do Frontend",
        "nextjsUI": "Frontend Next.js 15 com Shadcn UI e validação de formulários",
        "dockerRelease": "Release Docker",
        "fullStackDocker": "Deploy full-stack com Docker (v1.1)"
      }
    },
    "Actus": {
      "title": "ACTUS",
      "subtitle": "Plataforma de Validação e Compliance Contábil",
      "description": "ACTUS é um sistema integrado de gestão contábil que projetei e construí do zero na ACAOX Contabilidade. A plataforma aborda um desafio fundamental nas operações contábeis: garantir a representação fiel da realidade operacional por meio de validação automatizada de documentos e detecção de inconsistências. Processa documentos contábeis em múltiplos formatos — PDF, Excel e CSV — e aplica um motor de regras estruturado com mais de 284 regras de validação para detectar erros, avisos e alertas em balanços patrimoniais e razões contábeis. Cada regra é categorizada por nível de severidade e mapeada para classificações de contas específicas, permitindo que auditores priorizem questões de alto impacto. O motor de regras é alimentado por arquivos de configuração CSV em vez de lógica hardcoded, possibilitando que especialistas do domínio adicionem, modifiquem ou desabilitem regras sem alterações no código. Escolhi Spring Data JDBC ao invés de JPA deliberadamente — a carga de trabalho de validação é intensiva em leitura e orientada a lotes, onde o desempenho de SQL bruto e o controle explícito de queries superam a conveniência das abstrações ORM.",
      "features": "Processamento multi-formato (PDF, Excel, CSV); Cadastro de empresas em 7 etapas com perfis fiscal e contábil; Motor de regras CSV (284+ validações); Detecção de inconsistências por severidade; Importação de Plano de Contas (1.800+ registros); Dashboard com KPIs e gráficos; Exportação de relatórios em PDF; Controle de acesso com JWT; Upload drag-and-drop com classificação",
      "demo": {
        "login": "Página de Login",
        "dashboard": "Dashboard",
        "createCompany": "Cadastro de Empresa",
        "uploadDocument": "Upload de Documento",
        "documentFilled": "Envio de Documento",
        "chartOfAccounts": "Importação de Plano de Contas",
        "verification": "Verificação de Documento",
        "analytics": "Relatórios e Análises",
        "userManagement": "Gerenciamento de Usuários",
        "deployBuild": "Build de Deploy",
        "deployProduction": "Ambiente de Produção"
      },
      "statistics": {
        "totalCommits": "Total de Commits",
        "validationRules": "Regras de Validação",
        "dbMigrations": "Migrações de Banco",
        "documentTypes": "Tipos de Documento"
      },
      "timeline": {
        "projectStart": "Início do Projeto",
        "projectStartDesc": "Setup inicial do Spring Boot com autenticação, gestão de usuários e migrações de banco de dados",
        "coreFeatures": "Funcionalidades Principais",
        "coreFeaturesDesc": "Arquitetura de processamento de documentos, processamento de PDF, gestão de empresas e suporte multi-formato",
        "rulesEngine": "Motor de Regras e Validação",
        "rulesEngineDesc": "Motor de regras CSV com mais de 284 regras, validação multi-estratégia e relatórios em PDF",
        "releaseV1": "Release v1.01",
        "releaseV1Desc": "Máscara de inscrição federal, melhorias de UI, verificação de relatórios e deploy em produção"
      }
    },
    "AiRuleGenerator": {
      "title": "Gerador de Regras Contábeis com IA",
      "subtitle": "Sistema de Geração de Regras com RAG",
      "description": "Construir o motor de regras do ACTUS levantou uma questão natural: poderíamos automatizar a criação das próprias regras de validação? Desenvolvi um sistema standalone com IA que gera regras contábeis estruturadas usando Retrieval-Augmented Generation (RAG), combinando conhecimento específico do domínio dos pronunciamentos CPC brasileiros com as capacidades de raciocínio de modelos de linguagem de grande porte. O sistema produz 200–300 regras validadas por execução em formato CSV estruturado, prontas para serem consumidas diretamente pelo motor de regras do ACTUS. Cada regra inclui códigos de classificação de contas (com suporte a wildcard), lógica de validação, níveis de severidade, parâmetros configuráveis e justificativa regulatória. O pipeline consiste em três estágios sequenciais: coleta automatizada de pronunciamentos CPC, vetorização semântica com ChromaDB e geração estruturada de regras via Google Gemini 2.0 Flash. Inicialmente construí o sistema na API do Claude da Anthropic, mas migrei para o Gemini por eficiência de custo — o tier gratuito cobre execuções completas do pipeline a custo zero. A arquitetura foi projetada para extensibilidade: categorias de contas, fontes de verdade e backends de LLM são todos configuráveis via YAML.",
      "features": "RAG com ChromaDB e sentence-transformers; Coleta de pronunciamentos CPC via pdfplumber; Chunking semântico com overlap configurável; Engenharia de prompts com injeção de contexto; Pipeline de geração configurável via YAML; Execução a custo zero no tier gratuito do Gemini; Saída CSV compatível com ACTUS; Backends de LLM plugáveis (Gemini, Claude, GPT)",
      "statistics": {
        "rulesPerExecution": "Regras por Execução",
        "cpcPronouncementsIndexed": "Pronunciamentos CPC Indexados",
        "costPerRun": "Custo por Execução",
        "llmBackends": "Backends de LLM Suportados"
      },
      "timeline": {
        "ragSetup": "Infraestrutura RAG",
        "ragSetupDesc": "Setup do ChromaDB como vector store, embeddings sentence-transformer e pipeline de ingestão de documentos CPC",
        "ruleGeneration": "Pipeline de Geração de Regras",
        "ruleGenerationDesc": "Engenharia de prompts, saída CSV estruturada e integração com formato do motor de regras ACTUS",
        "optimization": "Otimização de Custos",
        "optimizationDesc": "Migração da API do Claude para o tier gratuito do Google Gemini 2.0 Flash para execução do pipeline a custo zero"
      }
    }
  },
  "MoreAbout": {
    "projectOverview": "Visão Geral do Projeto"
  },
  "KeyFeatures": {
    "keyFeatures": "Principais Funcionalidades"
  },
  "TechnicalSpecifications": {
    "technicalSpecifications": "Especificações Técnicas",
    "frontend": "Frontend",
    "backend": "Backend",
    "database": "Banco de Dados",
    "authentication": "Autenticação",
    "hosting": "Hospedagem",
    "performance": "Performance"
  },
  "ProjectStatistics": {
    "projectStatistics": "Estatísticas do Projeto"
  },
  "DevelopmentTimeline": {
    "developmentTimeline": "Linha do Tempo do Desenvolvimento"
  }
}
